#!/usr/bin/python
#    powernapd - monitor a system process table; if IDLE amount of time
#               goes by with no MONITORED_PROCESSES running, run ACTION
#    Copyright (C) 2009 Canonical Ltd.
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#             Adam Sutton <dev@adamsutton.me.uk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# #########################################################################
# Imports
# #########################################################################

import commands
import logging, logging.handlers
from logging import debug, info, warning, error
import os
import re
import signal
import sys
import time
import threading

# #########################################################################
# Configuration
# #########################################################################

PKG      = 'powernap'
CONFIG   = {
  'log'               : '/var/log/%s.log' % PKG,
  'pid'               : '/var/run/%s.pid' % PKG,
  'interval'          : 1.0,
  'absent'            : sys.maxint,
  'grace'             : 60.0,
  'debug'             : 0,
  'daemon'            : True,
  'action'            : '/usr/sbin/powernap',
  'monitors'          : [],
  'plugin_dir'        : './plugins',
}
RUNNING  = True
MONITORS = []

# Config signal handler
def sig_handler_config ( sig, frame ):
    if ( sig == signal.SIGHUP ):
        debug('TODO: do we need config reload support?')

# Load configuration
def load_config ():
    global PKG, CONFIG
    from optparse import OptionParser
    from ConfigParser import ConfigParser

    # Build options
    optp = OptionParser()
    optp.add_option("-c", "--config", dest="config",
                    default=None,
                    help="Specify an alternative configuration file")
    optp.add_option("-l", "--log", dest="log",
                    default=None,
                    help="Specify an alternative log file")
    optp.add_option("--pid", dest="pid",
                    default=None,
                    help="Specify an alternative PID file")
    optp.add_option("-i", "--interval", dest="interval",
                    default=None, type='float',
                    help="Specify interval period in seconds")
    optp.add_option("-a", "--absent", dest="absent",
                    default=None, type='float',
                    help="Specify global absent period in seconds")
    optp.add_option("-g", "--grace", dest="grace",
                    default=None, type='float',
                    help="Specify global grace period in seconds")
    optp.add_option("-d", "--debug", dest="debug",
                    default=None, type='int',
                    help="Specify level of debug logging")
    optp.add_option("--nodaemon", dest="daemon",
                    default=None,
                    action='store_false',
                    help="Do not run as a daemon process")
    optp.add_option('--monitor', dest='monitors',
                    default=[], action='append',
                    help='Specify monitor class to load')

    # Parse command line
    (opts,args) = optp.parse_args()

    # Get config file path
    conf_path   = '/etc/%s/config' % PKG
    if ( opts.config ): conf_path = opts.config

    # Load config file
    cfgp = ConfigParser()
    if ( os.path.isfile(conf_path) ): cfgp.read([conf_path])

    # Update from config file
    if cfgp.has_section('global'):
      for k, v in cfgp.items('global'):
        CONFIG[k] = eval(v)
        # TODO: how safe is this?

    # Update from command line
    if opts.log       != None: CONFIG['log']       = opts.log
    if opts.pid       != None: CONFIG['pid']       = opts.pid
    if opts.debug     != None: CONFIG['debug']     = opts.debug
    if opts.interval  != None: CONFIG['interval']  = opts.interval
    if opts.absent    != None: CONFIG['absent']    = opts.absent
    if opts.grace     != None: CONFIG['grace']     = opts.grace
    if opts.daemon    != None: CONFIG['daemon']    = opts.daemon
    if opts.monitors:          CONFIG['monitors']  = opts.monitors

# ###########################################################################
# Logging
# ###########################################################################

# Setup logging
def init_logging ():
    global CONFIG
    level  = logging.CRITICAL
    levels = [
        logging.CRITICAL,
        logging.ERROR,
        logging.WARNING,
        logging.INFO,
        logging.DEBUG ]
    if   CONFIG['debug'] < 0:            level = logging.CRITICAL
    elif CONFIG['debug'] >= len(levels): level = logging.DEBUG
    else:                                level = levels[CONFIG['debug']]
    logging.basicConfig(filename=CONFIG['log'], level=level,
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d_%H:%M:%S')

# Generic error function
def critical ( msg ):
    logging.critical(msg)
    sys.exit(1)

# ###########################################################################
# Daemon Setup
# ###########################################################################

# "Forking a Daemon Process on Unix" from The Python Cookbook
def init_daemon (stdin="/dev/null", stdout="/var/log/%s.log" % PKG, stderr="/var/log/%s.err" % PKG):

    # First fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #1 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # Setup environment
    os.chdir("/")
    os.setsid()

    # Second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #2 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # File handles
    for f in sys.stdout, sys.stderr: f.flush()
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

# Create PID file (locked)
def create_pid ():
    global CONFIG, PKG
    import fcntl
    f = None
    try:
        f = open(CONFIG['pid'], 'w')
    except:
        error("admin privileges are required to run %s" % PKG);
   
    try:
        fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
        f.write(str(os.getpid()))
    except:
        error("another instance is already running [pid=%s]" % f.read())

# Setup signal handlers
def init_signal_handlers ():
    signal.signal(signal.SIGHUP,  sig_handler_config)
    signal.signal(signal.SIGINT,  sig_handler_exit)
    signal.signal(signal.SIGQUIT, sig_handler_exit)
    signal.signal(signal.SIGTERM, sig_handler_exit)
    signal.signal(signal.SIGUSR1, sig_handler_take_action)

# Clean up lock file on termination signals
def sig_handler_exit ( sig, frame ):
    # Force shutdown!
    if ( sig == signal.SIGTERM ):
      info('forcing shutdown')
      sys.exit(1)
    else:
      global RUNNING
      info('requesting shutdown')
      RUNNING = False


# ###########################################################################
# Monitors
#   monitors are the key element in this system, they monitor particular
#   aspects of the system to determine if activity is present that should
#   stop the machine from going into suspend
#
#   The implementation is not as python like as it could be, its assumed
#   that all Monitor extend from the Monitor class which provides the basic
#   "stubbed" interface
#
#   Most monitors don't run seperate threads, however some do and therefore
#   the start/stop methods are added (could also be used to reset counts
#   etc...)
# ###########################################################################

# Generate monitors
#   TODO: this load system is crap, files must be ordered to work
#         but its just to prove basic concept
def create_monitors ( monitor_config ):
    ret = []

    # Source all plugins
    for f in os.listdir(CONFIG['plugin_dir']):
        p = os.path.join(CONFIG['plugin_dir'], f)
        if os.path.isfile(p):
            try:
                execfile(p, globals())
            except Exception, e:
                print 'ERROR: eval %s [e=%s]' % (p, str(e))

    # Process each
    for m in monitor_config:
        pts     = m.split('=', 2)
        monitor = globals()[pts[0]](eval(pts[1]))
        ret.append(monitor)

    return ret

# Generic monitor (doesn't really do much)
#   Note: as this is python there it's not required that anything extend from
#         this. It's merely here for conveinience and to serve as a guide as
#         to the required API that should be provided by Monitor objects
class Monitor ( object ):
    def __init__ ( self, config ):
        if not config.has_key('name'): config['name'] = 'unknown'
        self.name = config['name']
        debug("Creating monitor %s" % self.name)
    def __repr__ ( self ):
        return self.name

    # Reset monitor
    def reset ( self ): pass

    # Start the monitor
    def start ( self ): pass

    # Stop the monitor
    def stop  ( self ): pass

    # Check if monitored resource is active
    def active ( self ): return False


# Find list of PIDs that match a given regex (cmdline)
#   Note: I prefer using the /proc filesystem to ps output, less parsing is required!
def find_pids ( regex ):
    ret = []
  
    for d in os.listdir('/proc'):
        try:
            path = '/proc/%s/cmdline' % d
            if os.path.isfile(path):
                fp      = open(path)
                cmdline = fp.read()
                fp.close()
                if regex.search(cmdline):
                    ret.append(int(d))
        except: pass

    return ret

# ###########################################################################
# Actions
# ###########################################################################

# Enter sleep
def action_enter_sleep ():
    global CONFIG
    info('entering sleep')

    # Perform action
    if CONFIG.has_key('action_enter_sleep'):
        os.system(CONFIG['action_enter_sleep'])

# Exit sleep (woken up)
def action_exit_sleep ( period ):
    global CONFIG
    days   = int(period / 86400)
    period = period % 86400
    hrs    = int(asleep / 3600)
    period = period % 3600
    mins   = int(period / 60)
    secs   = period % 60
    debug('resumed after sleeping for %d days %02d hrs %02d mins %02d secs'
          % (days, hrs, mins, secs))

    # Perform action
    if CONFIG.has_key('action_exit_sleep'):
        os.system(CONFIG['action_exit_sleep'])

# Enter grace period
def action_enter_grace ():
    global CONFIG
    info('grace period entered')

    # Alert user
    msg1 = "PowerNap will take the following action in [%s] seconds: [%s]" % (CONFIG['grace'], CONFIG['action'])
    msg2 = "To cancel this operation, press any key in any terminal"
    commands.getoutput("echo '%s\n%s' | wall" % (msg1, msg2))

    # Perform action
    if CONFIG.has_key('action_enter_grace'):
        os.system(CONFIG['action_enter_grace'])

# Cancel grace period
def action_exit_grace ():
    global CONFIG
    debug('sleep cancelled')

    # Alert user
    msg = "PowerNap detected activity. Canceling action [%s]" % CONFIG['action']
    commands.getoutput("echo '%s' | wall" % msg)

    # Perform action
    if CONFIG.has_key('action_exit_grace'):
        os.system(CONFIG['action_exit_grace'])

# Handle external request to sleep
#   TODO: will not work well with state machine if we don't suspend!
def sig_handler_take_action ( sig, frame ):
    if ( sig == signal.SIGUSR1 ): action_enter_sleep()

# ###########################################################################
# State Machine
# ###########################################################################

# States
STATE_ACTIVE = 1 # Processes currently alive
STATE_GRACE  = 2 # In the grace period
STATE_SLEEP  = 3 # Currently inactive (possibly asleep)

# State machine
def powernapd_loop ():
    global RUNNING, CONFIG

    # Start state
    last_time = time.time()
    state     = STATE_ACTIVE
    grace     = 0

    # Until told to stop
    while RUNNING:

        # Wait
        debug('sleeping for %d seconds' % CONFIG['interval'])
        time.sleep(CONFIG['interval'])
        if not RUNNING: break # get out for interrupted sleep at shutdown

        # Get period
        now       = time.time()
        period    = now - last_time
        last_time = now

        # Check for activity
        debug('checking activity')
        active = 0
        for m in MONITORS:
            if m.active():
                debug('  %-30s is active' % m)
                active += 1
            else:
                debug('  %-30s is inactive' % m)

        # Activity detected
        if active > 0:
            info('activity detected [count = %d]' % active)

            # Woken up
            if state == STATE_SLEEP:
                action_exit_sleep()
        
            # Exit grace
            elif state == STATE_GRACE:
                action_exit_grace()

            # Else (ignore)
            else: pass
        
            # Set state
            state = STATE_ACTIVE

        # Enter grace period
        elif state == STATE_ACTIVE:
            action_enter_grace()

            # Set the period
            grace = CONFIG['grace']
            for m in MONITORS: grace = max(grace, m.grace())

            # Change state
            state = STATE_GRACE

        # Grace
        elif state == STATE_GRACE:
            grace -= period

            # Sleep
            if grace <= 0:
                action_enter_sleep()
                state = STATE_SLEEP

                # TODO: need to detect where we've actually gone to sleep
                #       and woken up!
    
            else:
                debug('grace period remaining %0.2f sec' % grace)

        # Sleeping
        elif state == STATE_SLEEP:
            pass

# ###########################################################################
# Main 
# ###########################################################################


# Main program
if __name__ == '__main__':

    # Configure everything
    load_config()
    init_logging()
    MONITORS = create_monitors(CONFIG['monitors'])

    # Process setup
    create_pid()
    init_signal_handlers()
    if CONFIG['daemon']: init_daemon()

    # Main loop
    info('starting monitors %s' % MONITORS)
    try:

        # Init monitors
        for m in MONITORS: m.start()

        # Enter state machine
        powernapd_loop()

    # Oh dear!
    except Exception, e:
        error("unhandled exception [e=%s]" % e)

    # Shut it all down
    finally:
        RUNNING = False
        for m in MONITORS: m.stop()
        info('terminating')
        sys.exit(0)

# ###########################################################################
# Editor directives
# ###########################################################################

# vim:sts=4:ts=4:sw=4:et
